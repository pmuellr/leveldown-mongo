// Generated by CoffeeScript 1.6.3
var AbstractLeveldown, Debug, JL, JS, MongoLeveldownIterator, async, fromMongoDoc, mongodb, toMongoDoc, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Debug = !false;

_ = require("underscore");

async = require("async");

mongodb = require("mongodb");

AbstractLeveldown = require("abstract-leveldown");

AbstractLeveldown.AbstractLevelDOWN.prototype.get = function(key, options, callback) {
  var err;
  if (typeof options === 'function') {
    callback = options;
  }
  if (typeof callback !== 'function') {
    throw new Error('get() requires a callback argument');
  }
  if ((err = this._checkKeyValue(key, 'key', this._isBuffer))) {
    return callback(err);
  }
  if (typeof options !== 'object') {
    options = {};
  }
  if (typeof this._get === 'function') {
    return this._get(key, options, callback);
  }
  return process.nextTick(function() {
    return callback(new Error('NotFound'));
  });
};

AbstractLeveldown.AbstractLevelDOWN.prototype.put = function(key, value, options, callback) {
  var err;
  if (typeof options === 'function') {
    callback = options;
  }
  if (typeof callback !== 'function') {
    throw new Error('put() requires a callback argument');
  }
  if ((err = this._checkKeyValue(key, 'key', this._isBuffer))) {
    return callback(err);
  }
  if ((err = this._checkKeyValue(value, 'value', this._isBuffer))) {
    return callback(err);
  }
  if (typeof options !== 'object') {
    options = {};
  }
  if (typeof this._put === 'function') {
    return this._put(key, value, options, callback);
  }
  return process.nextTick(callback);
};

AbstractLeveldown.AbstractLevelDOWN.prototype.del = function(key, options, callback) {
  var err;
  if (typeof options === 'function') {
    callback = options;
  }
  if (typeof callback !== 'function') {
    throw new Error('del() requires a callback argument');
  }
  if ((err = this._checkKeyValue(key, 'key', this._isBuffer))) {
    return callback(err);
  }
  if (typeof options !== 'object') {
    options = {};
  }
  if (typeof this._del === 'function') {
    return this._del(key, options, callback);
  }
  return process.nextTick(callback);
};

module.exports = function(mdb) {
  var MongoLeveldown;
  if (mdb == null) {
    throw Error("database argument was null");
  }
  if (!(mdb instanceof mongodb.Db)) {
    throw Error("database argument not instance of mongodb.Db");
  }
  return MongoLeveldown = (function(_super) {
    __extends(MongoLeveldown, _super);

    MongoLeveldown.destroy = function(location, callback) {
      if (Debug) {
        console.log("MongoLeveldown::destroy(" + location + ")");
      }
      return mdb.dropCollection(location, function(err) {
        if (err) {
          return callback(err);
        }
        return callback();
      });
    };

    MongoLeveldown.repair = function(location, callback) {
      if (Debug) {
        console.log("MongoLeveldown::repair(" + location + ")");
      }
      return process.nextTick(function() {
        return callback();
      });
    };

    function MongoLeveldown(location, options) {
      if (!(this instanceof MongoLeveldown)) {
        return new MongoLeveldown(location, options);
      }
      if (Debug) {
        console.log("new MongoLeveldown(" + location + ", " + (JS(options)) + ")");
      }
      MongoLeveldown.__super__.constructor.call(this, location, options);
    }

    MongoLeveldown.prototype._open = function(options, callback) {
      var mdbOptions,
        _this = this;
      if (Debug) {
        console.log("MongoLeveldown._open(" + this.location + ", " + (JS(options)) + ")");
      }
      mdbOptions = {
        w: 1,
        fsync: true
      };
      if (options.createIfMissing === false) {
        mdbOptions.strict = true;
      }
      return mdb.collection(this.location, mdbOptions, function(err, coll) {
        var indexOpts;
        if (err != null) {
          return callback(err);
        }
        if (options.errorIfExists) {
          return callback(Error("collection already exists: " + _this.location));
        }
        _this.coll = coll;
        indexOpts = {
          w: 1,
          fsync: true,
          unique: true,
          dropDups: true,
          name: "level-db-key"
        };
        return coll.ensureIndex({
          key: 1
        }, indexOpts, function(err) {
          if (err != null) {
            return callback(err);
          }
          return callback();
        });
      });
    };

    MongoLeveldown.prototype._close = function(callback) {
      if (Debug) {
        console.log("MongoLeveldown._close(" + this.location + ")");
      }
      return process.nextTick(function() {
        return callback();
      });
    };

    MongoLeveldown.prototype._get = function(key, options, callback) {
      var mongoDoc,
        _this = this;
      if (options == null) {
        options = {};
      }
      if (options.asBuffer == null) {
        options.asBuffer = true;
      }
      if (Debug) {
        console.log("MongoLeveldown._get(" + this.location + ", " + (JS(key)) + ", " + (JS(options)) + ")");
      }
      mongoDoc = toMongoDoc({
        key: key
      });
      return this.coll.findOne(mongoDoc, function(err, doc) {
        var val;
        if (err != null) {
          return callback(err);
        }
        if (Debug) {
          console.log("_get(" + key + "): " + (JSON.stringify(doc)));
        }
        if (doc == null) {
          return callback(Error("NotFound"));
        }
        val = fromMongoDoc(doc, {
          valAsBuffer: options.asBuffer
        }).val;
        return callback(null, val);
      });
    };

    MongoLeveldown.prototype._put = function(key, val, options, callback) {
      var keyDoc, mdbOptions, mongoDoc,
        _this = this;
      if (Debug) {
        console.log("MongoLeveldown._put(" + this.location + ", " + (JS(key)) + ", " + (JS(val)) + ", " + (JS(options)) + ")");
      }
      mdbOptions = {
        w: 1
      };
      if (options.sync) {
        mdbOptions.fsync = true;
      }
      mongoDoc = toMongoDoc({
        key: key,
        val: val
      });
      keyDoc = toMongoDoc({
        key: key
      });
      if (Debug) {
        console.log("_put(" + key + "): " + (JSON.stringify(mongoDoc)));
      }
      return this.coll.remove(keyDoc, mdbOptions, function(err) {
        if (err != null) {
          return callback(err);
        }
        return _this.coll.insert(mongoDoc, mdbOptions, function(err) {
          if (err != null) {
            return callback(error);
          }
          return callback();
        });
      });
    };

    MongoLeveldown.prototype._del = function(key, options, callback) {
      var mdbOptions, mongoDoc;
      if (Debug) {
        console.log("MongoLeveldown._del(" + this.location + ", " + (JS(key)) + ", " + (JS(options)) + ")");
      }
      mdbOptions = {
        w: 1
      };
      if (options.sync) {
        mdbOptions.fsync = true;
      }
      mongoDoc = toMongoDoc({
        key: key
      });
      return this.coll.remove(mongoDoc, mdbOptions, function(err) {
        if (err != null) {
          return callback(err);
        }
        return callback();
      });
    };

    MongoLeveldown.prototype._batch = function(array, options, callback) {
      var process,
        _this = this;
      if (Debug) {
        console.log("MongoLeveldown._batch(" + this.location + ", " + (JS(options)) + ")");
      }
      if (Debug) {
        console.log("" + (JL(array)));
      }
      process = function(item, callback) {
        var key, type, value;
        type = item.type, key = item.key, value = item.value;
        if (type === "del") {
          return _this.del(key, options, callback);
        } else if (type === "put") {
          return _this.put(key, value, options, callback);
        }
      };
      return async.each(array, process, function(err) {
        if (err != null) {
          return callback(err);
        }
        return callback();
      });
    };

    MongoLeveldown.prototype._approximateSize = function(start, end, callback) {
      if (Debug) {
        console.log("MongoLeveldown._approximateSize(" + this.location + ")");
      }
      return 0;
    };

    MongoLeveldown.prototype._iterator = function(options) {
      return new MongoLeveldownIterator(this, options);
    };

    MongoLeveldown.prototype._find4iterator = function(options, callback) {
      var fields, findOptions, gtKey, ltKey, query, sortOrder;
      fields = {};
      if (options.end === "") {
        delete options.end;
      }
      if (options.keys) {
        fields.key = 1;
        fields.keyType = 1;
      }
      if (options.values) {
        fields.val = 1;
        fields.valType = 1;
      }
      query = {};
      if (options.exclusiveStart) {
        gtKey = "$gt";
        ltKey = "$lt";
      } else {
        gtKey = "$gte";
        ltKey = "$lte";
      }
      if (options.start) {
        options.start = (toMongoDoc({
          key: options.start
        })).key;
      }
      if (options.end) {
        options.end = (toMongoDoc({
          key: options.end
        })).key;
      }
      if (!options.reverse) {
        if ((options.start != null) && (options.end != null)) {
          query.$and = [
            {
              key: {}
            }, {
              key: {
                $lte: options.end
              }
            }
          ];
          query.$and[0].key[gtKey] = options.start;
        } else if (options.start != null) {
          query.key = {};
          query.key[gtKey] = options.start;
        } else if (options.end != null) {
          query.key = {
            $lte: options.end
          };
        }
      } else {
        if ((options.start != null) && (options.end != null)) {
          query.$and = [
            {
              key: {}
            }, {
              key: {
                $gte: options.end
              }
            }
          ];
          query.$and[0].key[ltKey] = options.start;
        } else if (options.start != null) {
          query.key = {};
          query.key[ltKey] = options.start;
        } else if (options.end != null) {
          query.key = {
            $gte: options.end
          };
        }
      }
      if (options.reverse) {
        sortOrder = -1;
      } else {
        sortOrder = 1;
      }
      findOptions = {
        sort: {
          key: sortOrder
        }
      };
      if (options.limit !== -1) {
        findOptions.limit = options.limit;
      }
      console.log("coll.find(" + (JS(query)) + ", " + (JS(fields)) + ", " + (JS(findOptions)) + "), ");
      return this.coll.find(query, fields, findOptions);
    };

    return MongoLeveldown;

  })(AbstractLeveldown.AbstractLevelDOWN);
};

MongoLeveldownIterator = (function(_super) {
  __extends(MongoLeveldownIterator, _super);

  function MongoLeveldownIterator(db, options) {
    var _this = this;
    MongoLeveldownIterator.__super__.constructor.call(this, db);
    this._options = {
      start: options.start,
      end: options.end,
      reverse: options.reverse != null ? !!options.reverse : false,
      keys: options.keys != null ? !!options.keys : true,
      values: options.values != null ? !!options.values : true,
      limit: options.limit != null ? options.limit : -1,
      keyAsBuffer: options.keyAsBuffer != null ? !!options.keyAsBuffer : true,
      valueAsBuffer: options.valueAsBuffer != null ? !!options.valueAsBuffer : true,
      exclusiveStart: options.exclusiveStart != null ? !!options.exclusiveStart : false
    };
    this._error = null;
    this._cursor = this.db._find4iterator(this._options, function(err) {
      return _this._error = err;
    });
  }

  MongoLeveldownIterator.prototype._next = function(callback) {
    var _this = this;
    if (this._error != null) {
      this._cursor.close();
      return callback(err);
    }
    if (this._cursor.isClosed()) {
      return callback();
    }
    if (this._ended) {
      this._cursor.close();
      return callback();
    }
    this._cursor.nextObject(function(err, item) {
      var key, val, _ref;
      if (err != null) {
        _this._cursor.close();
        return callback(err);
      }
      if (item == null) {
        _this._cursor.close();
        return callback();
      }
      _ref = fromMongoDoc(item, {
        keyAsBuffer: _this._options.keyAsBuffer,
        valAsBuffer: _this._options.valueAsBuffer
      }), key = _ref.key, val = _ref.val;
      if (Debug) {
        console.log("next() calling cb: " + (JS({
          key: key,
          val: val
        })));
      }
      if (Debug) {
        console.log("   key: ", key);
      }
      if (Debug) {
        console.log("   val: ", val);
      }
      return callback(null, key, val);
    });
  };

  return MongoLeveldownIterator;

})(AbstractLeveldown.AbstractIterator);

toMongoDoc = function(_arg) {
  var doc, key, val;
  key = _arg.key, val = _arg.val;
  doc = {};
  if (key != null) {
    if (Buffer.isBuffer(key)) {
      doc.keyType = "b";
      doc.key = key.toString("hex");
    } else if (typeof key === "string") {
      doc.keyType = "s";
      doc.key = (new Buffer(key)).toString("hex");
    } else {
      doc.keyType = "j";
      doc.key = (new Buffer(JSON.stringify(key))).toString("hex");
    }
  }
  if (val != null) {
    if (Buffer.isBuffer(val)) {
      doc.valType = "b";
      doc.val = val.toString("hex");
    } else if (typeof val === "string") {
      doc.valType = "s";
      doc.val = (new Buffer(val)).toString("hex");
    } else {
      doc.valType = "j";
      doc.val = (new Buffer(JSON.stringify(val))).toString("hex");
    }
  }
  return doc;
};

fromMongoDoc = function(doc, _arg) {
  var buffer, key, keyAsBuffer, val, valAsBuffer;
  keyAsBuffer = _arg.keyAsBuffer, valAsBuffer = _arg.valAsBuffer;
  if (Debug) {
    console.log("fromMongoDoc(" + (JS(doc)) + ", {keyasBuffer:" + keyAsBuffer + ", valAsBuffer:" + valAsBuffer + ")");
  }
  key = null;
  val = null;
  if ((doc.keyType != null) && (doc.key != null)) {
    buffer = new Buffer(doc.key, "hex");
    if (doc.keyType === "b" || keyAsBuffer) {
      key = buffer;
    } else if (doc.keyType === "s") {
      key = buffer.toString();
    } else if (doc.keyType === "j") {
      key = JSON.parse(buffer.toString());
    } else {
      throw Error("invalid keyType: " + doc.keyType);
    }
  }
  if ((doc.valType != null) && (doc.val != null)) {
    buffer = new Buffer(doc.val, "hex");
    if (doc.valType === "b" || valAsBuffer) {
      val = buffer;
    } else if (doc.valType === "s") {
      val = buffer.toString();
    } else if (doc.valType === "j") {
      val = JSON.parse(buffer.toString());
    } else {
      throw Error("invalid valType: " + doc.valType);
    }
  }
  return {
    key: key,
    val: val
  };
};

JS = function(object) {
  return JSON.stringify(object);
};

JL = function(object) {
  return JSON.stringify(object, null, 4);
};
