// Generated by CoffeeScript 1.6.3
var AbstractLeveldown, Debug, JL, JS, MongoLeveldownIterator, buffer, isBuffer, mongodb, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Debug = true;

buffer = require("buffer");

_ = require("underscore");

mongodb = require("mongodb");

AbstractLeveldown = require("abstract-leveldown");

module.exports = function(mdb) {
  var MongoLeveldown;
  if (mdb == null) {
    throw Error("database argument was null");
  }
  if (!(mdb instanceof mongodb.Db)) {
    throw Error("database argument not instance of mongodb.Db");
  }
  return MongoLeveldown = (function(_super) {
    __extends(MongoLeveldown, _super);

    MongoLeveldown.destroy = function(location, callback) {
      if (Debug) {
        console.log("MongoLeveldown::destroy(" + location + ")");
      }
      return mdb.dropCollection(location, function(err) {
        if (err) {
          return callback(err);
        }
        return callback();
      });
    };

    MongoLeveldown.repair = function(location, callback) {
      if (Debug) {
        console.log("MongoLeveldown::repair(" + location + ")");
      }
      return process.nextTick(function() {
        return callback();
      });
    };

    function MongoLeveldown(location, options) {
      if (!(this instanceof MongoLeveldown)) {
        return new MongoLeveldown(location, options);
      }
      if (Debug) {
        console.log("new MongoLeveldown(" + location + ", " + (JS(options)) + ")");
      }
      MongoLeveldown.__super__.constructor.call(this, location, options);
    }

    MongoLeveldown.prototype._open = function(options, callback) {
      var mdbOptions,
        _this = this;
      if (Debug) {
        console.log("MongoLeveldown._open(" + this.location + ", " + (JS(options)) + ")");
      }
      mdbOptions = {
        w: 1,
        fsync: true
      };
      if (options.createIfMissing === false) {
        mdbOptions.strict = true;
      }
      return mdb.collection(this.location, mdbOptions, function(err, coll) {
        var indexOpts;
        if (err != null) {
          return callback(err);
        }
        if (options.errorIfExists) {
          return callback(Error("collection already exists: " + _this.location));
        }
        _this.coll = coll;
        indexOpts = {
          w: 1,
          fsync: true,
          unique: true,
          dropDups: true,
          name: "level-db-key"
        };
        return coll.ensureIndex({
          key: 1
        }, indexOpts, function(err) {
          if (err != null) {
            return callback(err);
          }
          return callback();
        });
      });
    };

    MongoLeveldown.prototype._close = function(callback) {
      if (Debug) {
        console.log("MongoLeveldown._close(" + this.location + ")");
      }
      return process.nextTick(function() {
        return callback();
      });
    };

    MongoLeveldown.prototype._get = function(key, options, callback) {
      var _this = this;
      if (options == null) {
        options = {};
      }
      if (options.asBuffer == null) {
        options.asBuffer = true;
      }
      if (Debug) {
        console.log("MongoLeveldown._get(" + this.location + ", " + (JS(key)) + ", " + (JS(options)) + ")");
      }
      return this.coll.findOne({
        key: key
      }, function(err, doc) {
        var val;
        if (err != null) {
          return callback(err);
        }
        if (Debug) {
          console.log("_get(" + key + "): " + (JSON.stringify(doc)));
        }
        if (doc == null) {
          return callback(Error("NotFound"));
        }
        val = doc.val;
        if (options.asBuffer) {
          val = new buffer.Buffer(val, "utf8");
        }
        return callback(null, val);
      });
    };

    MongoLeveldown.prototype._put = function(key, val, options, callback) {
      var doc, mdbOptions,
        _this = this;
      if (Debug) {
        console.log("MongoLeveldown._put(" + this.location + ", " + (JS(key)) + ", " + (JS(val)) + ", " + (JS(options)) + ")");
      }
      mdbOptions = {
        w: 1
      };
      if (options.sync) {
        mdbOptions.fsync = true;
      }
      doc = {
        key: key,
        val: val
      };
      if (isBuffer(val)) {
        doc.val = val.toString("utf8");
      }
      if (Debug) {
        console.log("_put(" + key + "): " + (JSON.stringify(doc)));
      }
      return this.coll.remove({
        key: key
      }, mdbOptions, function(err) {
        if (err != null) {
          return callback(err);
        }
        return _this.coll.insert(doc, mdbOptions, function(err) {
          if (err != null) {
            return callback(error);
          }
          return callback();
        });
      });
    };

    MongoLeveldown.prototype._del = function(key, options, callback) {
      var mdbOptions;
      if (Debug) {
        console.log("MongoLeveldown._del(" + this.location + ", " + (JS(key)) + ", " + (JS(options)) + ")");
      }
      mdbOptions = {
        w: 1
      };
      if (options.sync) {
        mdbOptions.fsync = true;
      }
      return this.coll.remove({
        key: key
      }, mdbOptions, function(err) {
        if (err != null) {
          return callback(err);
        }
        return callback();
      });
    };

    MongoLeveldown.prototype._batch = function(array, options, callback) {
      var doc, key, type, val, value, _i, _len, _ref;
      if (Debug) {
        console.log("MongoLeveldown._batch(" + this.location + ", " + (JS(options)) + ")");
      }
      if (Debug) {
        console.log("" + (JL(array)));
      }
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        _ref = array[_i], type = _ref.type, key = _ref.key, value = _ref.value;
        val = value;
        doc = {
          key: key,
          val: val
        };
        if (type === "del") {
          this.coll.remove({
            key: key
          }, {
            w: 0
          });
        } else if (type === "put") {
          this.coll.remove({
            key: key
          }, {
            w: 0
          });
          this.coll.insert(doc, {
            w: 0
          });
        }
      }
      return process.nextTick(function() {
        return callback();
      });
    };

    MongoLeveldown.prototype._approximateSize = function(start, end, callback) {
      if (Debug) {
        console.log("MongoLeveldown._approximateSize(" + this.location + ")");
      }
      return 0;
    };

    MongoLeveldown.prototype._iterator = function(options) {
      return new MongoLeveldownIterator(this, options);
    };

    MongoLeveldown.prototype._find4iterator = function(options, callback) {
      var fields, gtKey, query, sortOrder;
      fields = {};
      if (options.keys) {
        fields.key = 1;
      }
      if (options.values) {
        fields.val = 1;
      }
      if (options.limit !== -1) {
        fields.array = {
          $slice: options.limit
        };
      }
      query = {};
      if (options.exclusiveStart) {
        gtKey = "$gt";
      } else {
        gtKey = "$gte";
      }
      if ((options.start != null) && (options.end != null)) {
        query.$and = [
          {
            key: {}
          }, {
            key: {
              $lte: options.end
            }
          }
        ];
        query.$and[0][key][gtKey] = options.start;
      } else if (options.start != null) {
        query.key = {};
        query.key[gtKey] = options.start;
      } else if (options.end != null) {
        query.key = {
          $lte: options.end
        };
      }
      console.log("coll.find(\n" + (JL(query)) + ",\n" + (JL(fields)) + ")");
      if (options.reverse) {
        sortOrder = -1;
      } else {
        sortOrder = 1;
      }
      return this.coll.find(query, fields).sort({
        key: sortOrder
      });
    };

    return MongoLeveldown;

  })(AbstractLeveldown.AbstractLevelDOWN);
};

MongoLeveldownIterator = (function(_super) {
  __extends(MongoLeveldownIterator, _super);

  function MongoLeveldownIterator(db, options) {
    var _this = this;
    MongoLeveldownIterator.__super__.constructor.call(this, db);
    this._options = {
      start: options.start,
      end: options.end,
      reverse: options.reverse != null ? !!options.reverse : false,
      keys: options.keys != null ? !!options.keys : true,
      values: options.values != null ? !!options.values : true,
      limit: options.limit != null ? options.limit : -1,
      keyAsBuffer: options.keyAsBuffer != null ? !!options.keyAsBuffer : true,
      valueAsBuffer: options.valueAsBuffer != null ? !!options.valueAsBuffer : true,
      exclusiveStart: options.exclusiveStart != null ? !!options.exclusiveStart : false
    };
    this._error = null;
    this._cursor = this.db._find4iterator(this._options, function(err) {
      return _this._error = err;
    });
  }

  MongoLeveldownIterator.prototype._next = function(callback) {
    var _this = this;
    if (this._error != null) {
      this._cursor.close();
      return callback(err);
    }
    if (this._cursor.isClosed()) {
      return callback();
    }
    if (this._ended) {
      this._cursor.close();
      return callback();
    }
    return this._cursor.nextObject(function(err, item) {
      var key, val;
      if (err != null) {
        _this._cursor.close();
        return callback(err);
      }
      if (item == null) {
        _this._cursor.close();
        return callback();
      }
      key = item.key, val = item.val;
      if (_this._options.keyAsBuffer) {
        key = new buffer.Buffer(key, "utf8");
      }
      if (_this._options.valueAsBuffer) {
        val = new buffer.Buffer(val, "utf8");
      }
      console.log("next() calling cb: " + (JS({
        key: key,
        val: val
      })));
      return callback(null, key, val);
    });
  };

  return MongoLeveldownIterator;

})(AbstractLeveldown.AbstractIterator);

JS = function(object) {
  return JSON.stringify(object);
};

JL = function(object) {
  return JSON.stringify(object, null, 4);
};

isBuffer = function(object) {
  return buffer.Buffer.isBuffer(object);
};
